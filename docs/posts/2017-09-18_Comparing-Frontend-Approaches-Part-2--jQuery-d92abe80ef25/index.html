<ul>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-1-introduction-6cf3d49e42cf">Part 1: Introduction</a></li>
<li><strong>Part 2: jQuery</strong></li>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-3-vue-js-8b8614e4f324">Part 3: Vue.js</a></li>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-4-vue-js-with-components-675c880d4585">Part 4: Vue.js with components</a></li>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-5-react-b51fd7d075fe">Part 5: React</a></li>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-6-elm-578714526164">Part 6: Elm</a></li>
<li><a href="https://medium.com/@peterxjang/comparing-frontend-approaches-part-7-final-thoughts-69cdba516f86">Part 7: Final thoughts</a></li>
</ul>
<p><img src="img/1__7aM1iGhORpH__edtcYbtQsA.png" alt=""></p>
<p>In this part we will be implementing the <a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-1-introduction-6cf3d49e42cf">web based clone</a> of the <a href="https://support.apple.com/kb/PH22608?locale=en_US">Mac Notes app</a> using <a href="https://jquery.com/">jQuery</a>. jQuery is a JavaScript library that came out in 2006, and within several years became the most popular JavaScript library in use on the web (used by <a href="http://trends.builtwith.com/javascript/jQuery">70% of the top 100,000</a> sites online).</p>
<p>jQuery provides an intuitive API to directly manipulate the DOM to create interactive websites. In 2017, jQuery’s DOM manipulation approach is far less dominant, with templating and virtual DOM based approaches taking over. Nevertheless, jQuery remains an excellent library that’s reasonably lightweight, easy to get started with, and still used by many apps in production today. Let’s see what it’s like to use in practice!</p>
<blockquote>
<p>Note — one could argue that it would make more sense to start with vanilla JavaScript instead of jQuery, which is completely reasonable. jQuery provides some concise helper functions that makes it easier to demonstrate certain features, but you should feel free to mentally substitute any jQuery specific approaches I’m taking with the corresponding vanilla JavaScript — the general approach should be the same.</p>
</blockquote>
<h3 id="installation">Installation <a class="direct-link" href="#installation">#</a></h3>
<p>Starting from our <a href="https://jsfiddle.net/peterxjang/vtsjc5w9">initial template</a> in <a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-1-introduction-6cf3d49e42cf">part 1</a>, installing jQuery requires only 2 lines in the HTML head tag:</p>
<script src="https://code.jquery.com/jquery-3.2.1.js"  
  integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="  
  crossorigin="anonymous"></script>
<script src="js/notes.js" defer></script>
<p>The first line includes the jQuery library from a CDN (the integrity and crossorigin attributes are for <a href="https://www.w3.org/TR/SRI/">security</a> when using outside resources). The second line includes the app’s JavaScript and only has one change from the original template — the <code>defer</code> attribute. This ensures that the <code>notes.js</code> file is loaded only after the DOM is ready (before this attribute existed, you had to resort to tactics such as putting the script tag at the end of the body tag or using a <code>DOMContentLoaded</code> event listener wrapping your entire code).</p>
<h3 id="display-note-titles-from-an-array-of-notes">Display note titles from an array of notes <a class="direct-link" href="#display-note-titles-from-an-array-of-notes">#</a></h3>
<p>Now that jQuery’s installed, let’s change the starting template to generate the dynamic notes list using JavaScript.</p>
<p>Here I’m representing the notes as an array of objects, where each object has an id, a body, and a timestamp. The <code>Date.now()</code> returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.</p>
<p>var notes = [<br>
{id: 1, body: &quot;This is a first test&quot;, timestamp: Date.now()},<br>
{id: 2, body: &quot;This is a second test&quot;, timestamp: Date.now()},<br>
{id: 3, body: &quot;This is a third test&quot;, timestamp: Date.now()}<br>
];</p>
<p>Once we have the notes data, we can delete the placeholder HTML content and generate the note selectors ourselves:</p>
<p>notes.forEach(function(note) {<br>
$('.note-selectors').append(<br>
'<div class="note-selector">' +<br>
'<p class="note-selector-title">' + note.body + '</p>' +<br>
'<p class="note-selector-timestamp">' + note.timestamp + '</p>' +<br>
'</div>'<br>
);<br>
});</p>
<p>Here I’m using jQuery to both create new DOM elements and append them directly into the DOM. Right now I’m temporarily using the body and integer timestamp directly as the title and timestamp — they’ll need to be formatted appropriately to look pretty.</p>
<blockquote>
<p>Note that there is an additional concern that’s more subtle — adding the <code>note.body</code> directly into the DOM here can open up an <a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/">XSS vulnerability</a>, where a malicious user can enter a <code>&lt;script&gt;</code> tag in the HTML input and run unwanted JavaScript. You would need to sanitize the input yourself (oddly enough jQuery’s <code>.text()</code> method <a href="https://watchitlater.com/blog/2011/10/cross-site-scripting-vulnerability-with-javascript-and-jquery/">won’t be enough here</a>), which is one disadvantage of using a library over a framework (which generally have such security features built in).</p>
</blockquote>
<h3 id="use-methods-to-sort-and-format-notes">Use methods to sort and format notes <a class="direct-link" href="#use-methods-to-sort-and-format-notes">#</a></h3>
<p>Now let’s make helper methods to make sure the notes are sorted (newest first) and formatted properly (titles should be computed from the body, timestamps should be converted from milliseconds into a human readable string).</p>
<p>function transformNotes(notes) {<br>
return notes.slice().sort(function(a, b) {<br>
return b.timestamp - a.timestamp;<br>
});<br>
}</p>
<p>function formatTitle(body) {<br>
var maxLength = 20;<br>
if (body.length &gt; maxLength) {<br>
return body.substring(0, maxLength - 3) + '...';<br>
} else if (body.length === 0) {<br>
return &quot;New note&quot;;<br>
} else {<br>
return body;<br>
}<br>
}</p>
<p>function formatTimestamp(timestamp) {<br>
return new Date(timestamp).toUTCString();<br>
}</p>
<p>The logic here is somewhat simplified — the title should account for line breaks, the string output from the native <code>toUTCString</code> isn’t the prettiest, etc. However, since they are separate pure functions, it will be simple to make them more robust later. The loop would be modified to use the functions as follows:</p>
<p>transformNotes(notes).forEach(function(note) {<br>
$('.note-selectors').append(<br>
'<div class="note-selector">' +<br>
'<p class="note-selector-title">' + formatTitle(note.body) + '</p>' +<br>
'<p class="note-selector-timestamp">' + formatTimestamp(note.timestamp) + '</p>' +<br>
'</div>'<br>
);<br>
});</p>
<h3 id="select-a-note-on-title-click">Select a note on title click <a class="direct-link" href="#select-a-note-on-title-click">#</a></h3>
<p>Now let’s implement the ability to actually select notes. Clicking on a note title should both highlight the selected note on the left as well as display the contents in the editor on the right. Here’s a complete working example, which we’ll go over in detail:</p>
<p>First we need to keep track of a new variable <code>selectedNote</code> (which we’ll default to the first note).</p>
<p>var notes = [<br>
{id: 1, body: &quot;This is a first test&quot;, timestamp: Date.now()},<br>
{id: 2, body: &quot;This is a second test&quot;, timestamp: Date.now()},<br>
{id: 3, body: &quot;This is a third test&quot;, timestamp: Date.now()}<br>
];<br>
var selectedNote = notes[0];</p>
<p>Now comes the tricky part — in order to be able to click on a note title and display its corresponding information, we need to create a binding between the DOM and the data in JavaScript. One way to pull this off is by embedding the relevant data into the DOM using <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes">HTML data-* attributes</a>. In this case, each time I’m creating a new note selector DOM element with jQuery, I want to add the relevant note data into the DOM element itself using <code>data-id</code>, <code>data-body</code>, and <code>data-timestamp</code> attributes. For the sake of code organization, I extracted the code that creates the note selector DOM elements to a function called <code>domCreateNoteSelectors</code>:</p>
<p>function domCreateNoteSelectors(notes, selectedNote) {<br>
transformNotes(notes).forEach(function(note) {<br>
var $noteSelector = $(<br>
'<div class="note-selector' + (note === selectedNote ? ' active' : '') + '">' +<br>
'<p class="note-selector-title">' + formatTitle(note.body) + '</p>' +<br>
'<p class="note-selector-timestamp">' + formatTimestamp(note.timestamp) + '</p>' +<br>
'</div>'<br>
);<br>
$noteSelector.data(note);<br>
$('.note-selectors').append($noteSelector);<br>
});<br>
}</p>
<p>Note the variable name <code>$noteSelector</code> is using the convention of putting a $ in front of any variable which represents a DOM element. The key line which binds the data in JavaScript to the DOM is:</p>
<pre><code>$noteSelector.data(note);
</code></pre>
<p>This handy jQuery method takes all the keys in the <code>note</code> object (in this case <code>id</code>, <code>body</code>, and <code>timestamp</code>) and creates corresponding data-* attributes in the DOM element (in this case <code>data-id</code>, <code>data-body</code>, and <code>data-timestamp</code>).</p>
<p>Now that we have data binding, we’ll need to make an event listener to trigger whenever the user clicks on a note title:</p>
<p>$('.note-selectors').on('click', '.note-selector', function() {<br>
$('.note-selector').removeClass('active');<br>
$(this).addClass('active');<br>
domUpdateNoteEditor($(this).data());<br>
});</p>
<p>(Note that I’m putting a delegated event listener on the <code>.note-selectors</code> DOM element and not on the <code>.note-selector</code> directly— this is because the <code>.note-selector</code> elements don’t exist until later!) The event listener has two responsibilities — one is to update the style such that the selector appears highlighted, which is achieved by removing the <code>.active</code> class from all note selectors, then adding it back to the note selector that was just clicked. The other responsibility is to update the note editor on the right to display the appropriate note data. The note data is extracted from the DOM using <code>$(this).data()</code>, and is passed to a separate <code>domUpdateNoteEditor</code> function:</p>
<p>function domUpdateNoteEditor(selectedNote) {<br>
$('.note-editor-info')<br>
.html(formatTimestamp(selectedNote.timestamp));<br>
$('.note-editor-input')<br>
.val(selectedNote.body);<br>
}</p>
<h3 id="edit-the-selected-note-on-editor-input">Edit the selected note on editor input <a class="direct-link" href="#edit-the-selected-note-on-editor-input">#</a></h3>
<p>Next we’ll bind the <code>&lt;textarea&gt;</code> to the note data. Each time the user changes the text, there’s quite a few things that need to be updated:</p>
<ul>
<li>The underlying note data (body and timestamp)</li>
<li>The displayed timestamp in the note editor</li>
<li>The displayed title and timestamp in the current note selector</li>
<li>The sort order of the note selectors (the current one should be on top)</li>
</ul>
<p>Here’s the code to make all these changes happen:</p>
<p>$('.note-editor-input').on('input propertychange', function(event) {<br>
// Update the note data<br>
var body = $(this).val();<br>
var timestamp = Date.now();<br>
$('.note-selector.active').data('body', body);<br>
$('.note-selector.active').data('timestamp', timestamp);</p>
<p>// Update the DOM note editor timestamp<br>
$('.note-editor-info').html(formatTimestamp(timestamp));</p>
<p>// Update the DOM currently selected note selector<br>
$('.note-selector.active .note-selector-title')<br>
.html(formatTitle(body));<br>
$('.note-selector.active .note-selector-timestamp')<br>
.html(formatTimestamp(timestamp));</p>
<p>// Update the DOM note selectors sorting order<br>
var $active = $('.note-selector.active').detach();<br>
$('.note-selectors').prepend($active);<br>
});</p>
<p>This is where we start to see some difficulties with jQuery — while the DOM manipulation code itself is fairly straightforward, it becomes more and more complicated to remember the different parts of the DOM that need to be updated with each change.</p>
<h3 id="create-a-new-note-with-a-button">Create a new note with a button <a class="direct-link" href="#create-a-new-note-with-a-button">#</a></h3>
<p>Now let’s implement the ability to create a new note. Clicking on the “New” button should create a new note (new id, no body, current timestamp). The new note should become the currently selected note and appear at the top of the list of note selectors. Here’s a complete working example, which we’ll go over in detail:</p>
<p>Originally we made the <code>domCreateNoteSelectors</code> function to create note selectors in a loop. We’ll need to extract the code to make a single note selector into a separate <code>domCreateNoteSelector</code> function (so we can reuse it with the new note button):</p>
<p>function domCreateNoteSelector(note, selectedNote) {<br>
var $noteSelector = $(<br>
'<div class="note-selector' + (note === selectedNote ? ' active' : '') + '">' +<br>
'<p class="note-selector-title">' + formatTitle(note.body) + '</p>' +<br>
'<p class="note-selector-timestamp">' + formatTimestamp(note.timestamp) + '</p>' +<br>
'</div>'<br>
);<br>
$noteSelector.data(note);<br>
return $noteSelector;<br>
}</p>
<p>// ...</p>
<p>function domCreateNoteSelectors(notes, selectedNote) {<br>
transformNotes(notes).forEach(function(note) {<br>
var $noteSelector = domCreateNoteSelector(note, selectedNote);<br>
$noteSelector.data(note);<br>
$('.note-selectors').append($noteSelector);<br>
});<br>
}</p>
<p>Here’s the code that runs when the user clicks the “New” button (note that I added the <code>.toolbar-button-new</code> class in the HTML to make it easier to target the new button element):</p>
<p>$('.toolbar-button-new').on('click', function() {<br>
$('.note-selector').removeClass('active');<br>
var note = {<br>
id: Date.now(),<br>
body: &quot;&quot;,<br>
timestamp: Date.now()<br>
};<br>
var $noteSelector = domCreateNoteSelector(note, note);<br>
$('.note-selectors').prepend($noteSelector);<br>
domUpdateNoteEditor(note);<br>
});</p>
<p>Here I’m using <code>Date.now()</code> as a quick and dirty way of generating a id, it should be replaced with a more robust approach for a guaranteed unique id. In order to make sure the new note is highlighted, I first removed the <code>.active</code> class from all note selectors, then created the new note selector with the <code>domCreateNoteSelector</code> function, which takes in the note to create along with the currently selected note (which in this case is itself). This works fine, but again it’s getting a little harder to follow exactly how the DOM is being updated.</p>
<h3 id="delete-the-selected-note-with-a-button">Delete the selected note with a button <a class="direct-link" href="#delete-the-selected-note-with-a-button">#</a></h3>
<p>The delete button is in theory easy enough to implement — add an event listener to the “Delete” button which removes the currently selected note selector (which is marked with the class <code>.active</code>) from the DOM.</p>
<p>$('.toolbar-button-delete').on('click', function() {<br>
$('.note-selector.active').remove();<br>
});</p>
<p>Unfortunately, this doesn’t address what note should be marked as the currently selected note after the current one is deleted. Here’s a second attempt:</p>
<p>$('.toolbar-button-delete').on('click', function() {<br>
$('.note-selector.active').remove();<br>
var children = $('.note-selectors').children();<br>
var $noteSelector = $(children[0]);<br>
$noteSelector.addClass('active');<br>
domUpdateNoteEditor($noteSelector.data());<br>
});</p>
<p>This code will grab all the note selectors from the DOM and select the first one. Unfortunately, this doesn’t address what should happen when you delete the LAST note. Let’s say we want the app to hide the note editor completely if there are no notes:</p>
<p>$('.toolbar-button-delete').on('click', function() {<br>
$('.note-selector.active').remove();<br>
var children = $('.note-selectors').children();<br>
if (children.length &gt; 0) {<br>
var $noteSelector = $(children[0]);<br>
$noteSelector.addClass('active');<br>
domUpdateNoteEditor($noteSelector.data());<br>
} else {<br>
$('.note-editor').hide();<br>
}<br>
});</p>
<p>This works, but once the note editor is hidden, it will never unhide! So now we have to make sure the note editor is shown when you create a new note:</p>
<p>$('.toolbar-button-new').on('click', function() {<br>
$('.note-editor').show();<br>
//...<br>
});</p>
<p>This completely works now, but we’re getting into the territory of what is known as “jQuery spaghetti” — the delete note feature requires writing code in both the delete button event listener as well as the new button event listener, which is highly unintuitive. As more features get added to the app, these types of unrelated dependencies start cropping up in more and more places, making it harder to reason about the code.</p>
<h3 id="filter-notes-on-search-input">Filter notes on search input <a class="direct-link" href="#filter-notes-on-search-input">#</a></h3>
<p>The final feature I’m going to implement is to be able to search notes immediately as you type in the search input. Before we implement it, I’m first going to extract out the code from the delete event listener that selects the appropriate note when the list changes into a function called <code>domSelectDefaultChild</code>, since we’ll need similar functionality when dynamically searching.</p>
<p>function domSelectDefaultChild() {<br>
var children = $('.note-selector:visible');<br>
if (children.length &gt; 0) {<br>
var $noteSelector = $(children[0]);<br>
if ($('.note-selector.active').length === 0) {<br>
$noteSelector.addClass('active');<br>
domUpdateNoteEditor($noteSelector.data());<br>
}<br>
} else {<br>
$('.note-editor').hide();<br>
}<br>
}</p>
<p>// ...</p>
<p>$('.toolbar-button-delete').on('click', function() {<br>
$('.note-selector.active').remove();<br>
domSelectDefaultChild();<br>
});</p>
<p>Now let’s add an event listener on the search input. This code will need to do the following things:</p>
<ul>
<li>Show the note editor in case it’s hidden</li>
<li>Get the search text the user entered</li>
<li>Loop through each note selector and show or hide it based on whether or not the note’s body (in the DOM data-body attribute) matches the user’s search text</li>
<li>Select a new note if necessary</li>
</ul>
<p>The code to accomplish this is as follows:</p>
<p>$('.toolbar-search').on('input propertychange', function() {<br>
$('.note-editor').show();<br>
var searchNoteText = $(this).val();<br>
$('.note-selector').each(function() {<br>
var $note = $(this);<br>
if ($note.data().body.toLowerCase().indexOf(searchNoteText.toLowerCase()) === -1) {<br>
$note.hide();<br>
if ($note.hasClass('active')) {<br>
$note.removeClass('active');<br>
}<br>
} else {<br>
$note.show();<br>
}<br>
});<br>
domSelectDefaultChild();<br>
});</p>
<p>Here is the final working example in all its glory:</p>
<h3 id="conclusion">Conclusion <a class="direct-link" href="#conclusion">#</a></h3>
<p>I’ve noted in a couple of places where the jQuery code is starting to get hard to manage. Still, I would consider this app to be reasonably simple, so jQuery works well enough here, especially if you’re diligent about extracting reusable functions. There’s a certain beauty to jQuery where the code closely matches what you’re trying to accomplish in terms of DOM manipulation. However, it does get harder and harder to keep track of how the code is working as you add more features.</p>
<p>The approaches I’ve taken here certainly don’t represent the best or only way to implement these features. You may be able to better organize the code using advanced features like <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">mutation observers</a>, modules, etc. jQuery is unopinionated and allows you to come up with your own patterns to organize your code. But at that point, you may want to look at frameworks which have already established a set of patterns to make it easier to create new apps. In the <a href="https://medium.com/@peterxjang/comparing-frontend-frameworks-part-3-vue-js-8b8614e4f324">next part</a> of this series, we’ll take a look at building the same set of features from scratch using the <a href="https://vuejs.org/">Vue.js</a> framework. Stay tuned!</p>
